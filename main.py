from typing import Tuple, final
from projectq import MainEngine
from projectq.ops import H, Measure
from char_list import *
import json
import random

quantum_engine = MainEngine()
qubit = quantum_engine.allocate_qubit()


# A list containing the generated hashes with the word as the key and the hash as the value
hashes = []

# A list containing the sequence of numbers generated by the qubit
loop_sequence = []

class LyriHash():    

 
    def NormalHash(self, word, hashlength):
        
        hash = []
        for x in range(hashlength):
            index = random.randint(0, x)
            choose = random.randint(1, 4)

            try:
                if choose == 1:
                    hash.append(special_characters[index])
                elif choose == 2:
                    hash.append(letters_uppercase[index])
                elif choose == 3:
                    hash.append(letters_lowercase[index])
                else:
                    hash.append(bip32[index])
            except Exception:
                if choose == 1:
                    indexException = random.randint(0, (len(special_characters) - 1))
                    hash.append(special_characters[indexException])
                elif choose == 2:
                    indexException = random.randint(0, (len(letters_uppercase) - 1))
                    hash.append(letters_uppercase[indexException])
                elif choose == 3:
                    indexException = random.randint(0, (len(letters_lowercase) - 1))
                    hash.append(letters_lowercase[indexException])
                else:
                    hash.append(bip32[index])
        generated_hash = ''.join(hash)
        hashed_word = generated_hash + word

        hashed_dict = {word: generated_hash}

        with open('hashes.txt', 'a') as f:
            f.write(json.dumps(hashed_dict))
            f.write('\n')
        print('HASHED WORD: ' + hashed_word)

    def CheckPassword(self, hash):

        error = False
        with open('hashes.txt', 'r') as f:
            for x in f.readlines():
                if hash in x:
                    print('valid password')
                    print(x)
                    error = False
                    return True
                else:
                    error = True
            if not error:
                pass
            else:
                print("Could not verify password")
                    
    def BIP32_seek_phrase_gen(self, length):
        
        word_lst = []
        for x in range(length):
            index = random.randint(x, (len(bip32) - 1))
            if bip32[index] not in word_lst:
                word_lst.append(bip32[index])
            else:
                word_lst.append(bip32[index + 1])
        
        phrase = ' '.join(word_lst)
        print(phrase)

        with open('phrases.txt', 'r') as r:
            if phrase not in r.readlines():
                with open('phrases.txt', 'a') as f:
                    f.write(phrase)
                    f.write('\n')
            else:
                print(f"Generated phrase ({str(phrase)}) already exists in file, please try again")

    def CheckPhrase(self, phrase):
        
        error = False
        with open('phrases.txt', 'r') as r:
            for x in r.readlines():
                if phrase in x:
                    print('Phrase exists in the phrases file.')
                    error = False
                    break
                else:
                    error = True
            if not error:
                pass
            else:
                print("Phrase does not exist in the phrases file")


    def QuantumHash(self, word, hashlength):

        for x in range(hashlength):
            H | qubit        
            Measure | qubit

            if int(qubit) == 1:
                loop_sequence.append(' 1 ')
                hash = []
                for x in range(hashlength):
                    H | qubit        
                    Measure | qubit
                    index = random.randint(0, x)
                    choose = random.randint(1, 4)
                    
                    try:
                        if choose == 1:
                            hash.append(special_characters[index + int(qubit)])
                        elif choose == 2:
                            hash.append(letters_uppercase[index + int(qubit)])
                        elif choose == 3:
                            hash.append(letters_lowercase[index + int(qubit)])
                        else:
                            hash.append(bip32[index + int(qubit)])
                    except Exception:
                        if choose == 1:
                            indexException = random.randint(0, (len(special_characters) - 1))
                            hash.append(special_characters[indexException])
                        elif choose == 2:
                            indexException = random.randint(0, (len(letters_uppercase) - 1))
                            hash.append(letters_uppercase[indexException])
                        elif choose == 3:
                            indexException = random.randint(0, (len(letters_lowercase) - 1))
                            hash.append(letters_lowercase[indexException])
                        else:
                            hash.append(bip32[index])

            else:
                loop_sequence.append(' 0 ')
                hash = []
                for x in range(hashlength):
                    index = random.randint(0, x)
                    choose = random.randint(1, 4)

                    try:
                        if choose == 1:
                            hash.append(special_characters[index - int(qubit)])
                        elif choose == 2:
                            hash.append(letters_uppercase[index - int(qubit)])
                        elif choose == 3:
                            hash.append(letters_lowercase[index - int(qubit)])
                        else:
                            hash.append(bip32[index - int(qubit)])
                    except Exception:
                        if choose == 1:
                            indexException = random.randint(0, (len(special_characters) - 1))
                            hash.append(special_characters[indexException])
                        elif choose == 2:
                            indexException = random.randint(0, (len(letters_uppercase) - 1))
                            hash.append(letters_uppercase[indexException])
                        elif choose == 3:
                            indexException = random.randint(0, (len(letters_lowercase) - 1))
                            hash.append(letters_lowercase[indexException])
                        else:
                            hash.append(bip32[index])

        generated_hash = ''.join(hash)
        hashed_word = generated_hash + word

        hashed_dict = {word: generated_hash}
        if not LyriHash().CheckPassword(str(hash)):
            with open('quantum_hashes.txt', 'a') as f:
                f.write(json.dumps(hashed_dict))
                f.write(' quantum sequence: ')
                for x in loop_sequence:
                    f.write(x)
                f.write('\n')
            print('HASHED WORD: ' + hashed_word)
            print(f'Quantum Sequence: {loop_sequence}')
        else:
            LyriHash().QuantumHash(word, len(hash))

